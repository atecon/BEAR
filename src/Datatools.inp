function void head (const numeric target,
                    const int nrows[1::5])
    /* Prints the initial rows of some series, list of matrix. */
    head_tail(target, nrows)
end function


function void tail (const numeric target,
                    const int nrows[1::5])
    /* Prints the last rows of some series, list of matrix. */
    head_tail(target, -nrows)
end function


# Private function
function void head_tail (const numeric L, int nrows[::5])
    /* Return the first nrows rows of some series, list or matrix based on position.
    For negative values of nrows, this function returns the last |nrows| rows.
    If |nrows| is larger than the number of rows, this function returns all rows.
    If nrows  is zero, the function errors. */

    errorif(nrows == 0, "'nrows' cannot be zero")

    if typename(L) == "series" || typename(L) == "list"
        scalar nrows = abs(nrows) > $nobs ? sgn(nrows)*$nobs : nrows

        if nrows > 0
            print L --byobs --range=:nrows
        else
            print L --byobs --range=nrows:
        endif

    elif typename(L) == "matrix"
        scalar nrows = abs(nrows) > rows(L) ? sgn(nrows)*rows(L) : nrows

        if nrows > 0
            print L[1:nrows,]
        else
            scalar init = rows(L) + nrows + 1
            print L[init:,]
        endif

    endif
end function


function scalar is_str_series (const series y)
    /*
    Check if a given series is string-valued.

    Parameters:
    y (series): The series to check.

    Returns:
    scalar: Returns TRUE if the series is string-valued, otherwise returns FALSE.
    */

    if getinfo(y).has_string_table == TRUE
        return TRUE
    else
        return FALSE
    endif
end function


function matrix nuniq (const series target)
    /*
    Count the number of unique values in a given series. Missing values are
    ignored and not counted.

    Parameters:
    y (series): The series to count unique values in.

    Returns:
    matrix: The number of unique values in the series. If 'target' is a string
    series, the distinct string values are additionally printed as row labels.
    */

    matrix vals = uniq(target)
    matrix nvals = vals ~ NA

    loop i=1..nelem(vals)
        nvals[i,2] = sum(target .= vals[i])
    endloop

    cnameset(nvals, defarray("value", "n unique"))
    if is_str_series(target) == TRUE
        rnameset(nvals, strvals(target))
    endif

    return nvals
end function


function matrix nmissing (const numeric target)
    /*
    Calculate the number of missing values in a given series, list or matrix.

    The function checks the type of the input. If it's a series, it calculates the
    number of missing values in the series. If it's a list or matrix, it calculates
    the number of missing values for each series/column in the list and returns
    a matrix with the results.

    Parameters:
    target (series, list or matrix): The series, list or matrix to calculate the
    number of missing values for.

    Returns:
    matrix: If the input is a series, returns a matrix with one element - the
    number of missing values in the series. If the input is a list or matrix,
    returns a matrix with the number of missing values for each series in the
    list. The row names of the matrix are the variable names from the list, and
    the column name is "n missing".
    */

    set skip_missing off

    if typename(target) == "series"
        matrix res = sum(!ok(target))
        return res
    endif

    if typename(target) == "list"
        matrix res = sumc(!ok({target}))'
        rnameset(res, varnames(target))
        cnameset(res, defarray("n missing"))

    else # matrix case
        matrix res = sumc(!ok(target))'
        strings column_labels = cnameget(target)
        if nelem(column_labels)
            rnameset(res, column_labels)
        endif
    endif

    return res
end function


function matrix shape (const numeric target)
    /*
    Get the shape of a given series, list, or matrix.

    The function checks the type of the input. If it's a series, it returns a matrix with
    two elements: the number of observations and 1. If it's a list, it returns a matrix
    with two elements: the number of observations and the number of elements in the list.
    If it's a matrix, it returns a matrix with two elements: the number of rows and the
    number of columns in the matrix.

    Parameters:
    target (series, list, or matrix): The series, list, or matrix to get the shape of.

    Returns:
    matrix: A matrix with two elements: the number of rows (or observations) and the
    number of columns (or elements) in the input.

    Raises:
    error: If the input is not a series, list, or matrix.
    */

    if typename(target) == "series"
        matrix res = {$nobs, 1}
    elif typename(target) == "list"
        matrix res = {$nobs, nelem(target)}
    elif typename(target) == "matrix"
        matrix res = {rows(target), cols(target)}
    else
        errorif(TRUE, "unsupported data type")
    endif

    return res
end function


function void dtypes (const numeric target)
    /*
    Print the data types of a given series or list.

    The function checks the type of the input. If it's a series, it prints the data type
    of the series. If it's a list, it prints the data type of each series in the list.

    The data type of a series is determined by whether it has a string table and whether
    it's discrete. If the series has a string table, its data type is "string". If it's
    discrete, its data type is "discrete". Otherwise, its data type is "continuous".

    Parameters:
    target (series or list): The series or list to print the data types of.

    Raises:
    error: If the input is not a series or list.
    */

    errorif(typename(target) == "matrix", "Only series and list are accepted")

    printf "\nData series types:\n"

    if typename(target) == "series"
        bundle B = getinfo(target)
        string dtype = B.has_string_table ? "string" : B.discrete ? \
        "discrete" : "continuous"
        printf "%s\t -- %s\n", argname(target), dtype

    else
        loop foreach i target
            bundle B = getinfo(target.$i)
            string dtype = B.has_string_table ? "string" : B.discrete ? \
                "discrete" : "continuous"
            printf "%s\t -- %s\n", "$i", dtype
        endloop
        print ""
    endif
end function


function matrix agg (const numeric targets,
                     const numeric groupby,
                     const strings methods)
    /* code description
    return: type, description */

    errorif(typename(targets) != "series" && typename(targets) != "list",
            "'targets' must be either series or list.")
    errorif(typename(groupby) != "series" && typename(groupby) != "list",
            "'groupby' must be either series or list.")

    strings vname = typename(targets) == "series" ? argname(targets) : \
        varnames(targets)
    strings byvars_names = typename(groupby) == "series" ? argname(groupby) : \
        varnames(groupby)
    strings column_labels = byvars_names + "count"
    scalar nskip = typename(groupby) == "list" ? 2 + nelem(groupby) : 3

    loop foreach i methods
        column_labels += add_agg_method_label("$i", vname)

        if i == 1
            matrix result = aggregate(targets, groupby, "$i")
        else
            result ~= aggregate(targets, groupby, "$i")[,nskip:]
        endif
    endloop

    cnameset(result, column_labels)

    return result
end function


function strings add_agg_method_label (const string method,
                                      const strings vnames)
    /* Compile string used as column name for agg(). */

    strings S

    loop foreach i vnames
        S  += sprintf("%s(%s)", method, "$i")
    endloop

    return S
end function

